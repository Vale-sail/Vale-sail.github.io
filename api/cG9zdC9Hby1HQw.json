{"title":"Go GC","date":"2021-12-01T02:55:00.000Z","author":"Vale Sail","slug":"Go-GC","tags":["go"],"updated":"2021-12-01T06:10:40.474Z","content":"<h4 id=\"阶段示意图\">阶段示意图<a href=\"post/Go-GC#阶段示意图\"></a></h4><div class=\"article-img\"><p><img src=\"/images/image-gc-a.png\" alt=\"upload successful\" data-zoomable></p></div>\n<ol>\n<li>stack scan<blockquote>\n<p>收集根对象（全局变量和 goroutine 栈上的变量），该阶段会STW,开启读写屏障</p>\n</blockquote>\n</li>\n<li>mark 标记对象<blockquote>\n<p>标记对象，直至所有根对象可达的对象标记完成</p>\n</blockquote>\n</li>\n<li>mark termination<blockquote>\n<p>标记完成，重新扫描全局变量和栈上的变量，完成标记。<br>开启STW 写屏障</p>\n</blockquote>\n</li>\n<li>sweep<blockquote>\n<p>并发清除白色对象</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"三色标记\">三色标记<a href=\"post/Go-GC#三色标记\"></a></h4><ol>\n<li>黑色：已标记的对象，表示对象是根对象可达的。</li>\n<li>白色：未标记对象，gc开始时所有对象为白色，当gc结束时，如果仍为白色，说明对象不可达，在 sweep 阶段会被清除。</li>\n<li>灰色：被黑色对象引用到的对象，但其引用的自对象还未被扫描，灰色为标记过程的中间状态，当灰色对象全部被标记完成代表本次标记阶段结束。</li>\n</ol>\n<h5 id=\"三色标记的主要过程即：\">三色标记的主要过程即：<a href=\"post/Go-GC#三色标记的主要过程即：\"></a></h5><ol>\n<li>开始时所有对象为白色</li>\n<li>将所有根对象标记为灰色，放入队列</li>\n<li>遍历灰色对象，将其标记为黑色，并将他们引用的对象标记为灰色，放入队列</li>\n<li>重复步骤 <ol>\n<li>持续遍历灰色对象，直至队列为空</li>\n</ol>\n</li>\n<li>此时只剩下黑色对象和白色对象，白色对象即为下一步需要清除的对象</li>\n</ol>\n<h4 id=\"屏障\">屏障<a href=\"post/Go-GC#屏障\"></a></h4><h5 id=\"写屏障\">写屏障<a href=\"post/Go-GC#写屏障\"></a></h5><ol>\n<li>对象引用修改时，将引用的对象标记为灰色；<blockquote>\n<p>A(黑)-&gt;B(灰)-&gt;C(白) 修改 A(黑)-&gt;C(灰-写屏障) ，但是B(灰) 不会被回收</p>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"删除屏障\">删除屏障<a href=\"post/Go-GC#删除屏障\"></a></h5><ol>\n<li>对象操作时，将对象置为灰色<blockquote>\n<p>可能导致一些已经不被使用的对象，被标记为灰色。本轮将不会被回收<br>引入可以减少标记结束的re-scan时间，减少STW时间</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"GC触发\">GC触发<a href=\"post/Go-GC#GC触发\"></a></h4><ol>\n<li>主动触发</li>\n<li>sysmon监控进程发现长时间没有GC</li>\n<li>内存增长过快</li>\n</ol>\n<h4 id=\"内存分配\">内存分配<a href=\"post/Go-GC#内存分配\"></a></h4><blockquote>\n<p>逃逸分析是指由编译器决定内存分配的位置，不需要程序员指定。即由编译器决定新申请的对象会分配到堆上还是栈上。</p>\n</blockquote>\n<p>逃逸分析场景：</p>\n<ol>\n<li>指针逃逸 : go 将函数内定义的变量返回到函数外，会将本应分配到栈上的内存分配到堆上。</li>\n<li>栈空间不足逃逸: 当栈空间不足或无法判断当前切片长度时会将对象分配到堆上。</li>\n<li>动态类型逃逸: 当函数参数为 interface 类型，编译期间无法确定参数的具体类型，也可能会产生逃逸。</li>\n</ol>\n","prev":{"title":"GO基础","slug":"GO基础"},"next":{"title":"go Map","slug":"go-Map"},"link":"https://vale-sail.github.io/post/Go-GC/"}