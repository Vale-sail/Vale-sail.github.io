{"title":"GO基础","date":"2021-12-01T08:45:00.000Z","author":"Vale Sail","slug":"GO基础","tags":["go"],"categories":["学习笔记"],"updated":"2021-12-01T08:51:20.867Z","content":"<h4 id=\"for-range\">for range<a href=\"post/GO基础#for-range\"></a></h4><ol>\n<li>for range 支持三种遍历<ol>\n<li>for range</li>\n<li>for k = range </li>\n<li>for k,v = range  </li>\n</ol>\n</li>\n<li>for range 返回v 指向 数据的指针 。如果v的指针被使用，可能最后操作的都是一个数据</li>\n<li>map 遍历时，runtime 会随机生成一个随机数，让map遍历结果无序<ol>\n<li>选出一个绿色的正常桶开始遍历，随后遍历所有黄色的溢出桶，最后依次按照索引顺序遍历哈希表中其他的桶，直到所有的桶都被遍历完成</li>\n</ol>\n</li>\n<li>for range channel时，会判断channel是否关闭</li>\n</ol>\n<h4 id=\"select\">select<a href=\"post/GO基础#select\"></a></h4><ol>\n<li>已关闭的chan，会一直执行 返回chan的零值</li>\n</ol>\n<h4 id=\"defer\">defer<a href=\"post/GO基础#defer\"></a></h4><ol>\n<li>以出现的顺序入栈，执行 出栈的顺序； <ol>\n<li>以链表的方式链接多个defer。每次出现都追加到defer链表的最前面</li>\n<li>运行 runtime._defer 时是从前到后依次执行；</li>\n</ol>\n</li>\n<li>defer 使用传值的方式传递参数时会进行预计算<blockquote>\n<p>调用 runtime.deferproc 函数创建新的延迟调用时就会立刻拷贝函数的参数，函数的参数不会等到真正执行时计算；</p>\n</blockquote>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tstartedAt := time.Now()</span><br><span class=\"line\">\tdefer fmt.Println(time.Since(startedAt)) //值拷贝 预计算 程序打印 0 </span><br><span class=\"line\">\t</span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tstartedAt := time.Now()</span><br><span class=\"line\">\tdefer func() &#123; fmt.Println(time.Since(startedAt)) &#125;() // 值拷贝的是 整个defer函数，函数里面使用的 程序打印1\t</span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"panic-recover\">panic recover<a href=\"post/GO基础#panic-recover\"></a></h4><ol>\n<li>编译器会负责做转换关键字的工作；<ol>\n<li>将 panic 和 recover 分别转换成 runtime.gopanic 和 runtime.gorecover；</li>\n<li>将 defer 转换成 runtime.deferproc 函数；</li>\n<li>在调用 defer 的函数末尾调用 runtime.deferreturn 函数；</li>\n</ol>\n</li>\n<li>在运行过程中遇到 runtime.gopanic 方法时，会从 Goroutine 的链表依次取出 runtime._defer 结构体并执行；</li>\n<li>如果调用延迟执行函数时遇到了 runtime.gorecover 就会将 _panic.recovered 标记成 true 并返回 panic 的参数；<ol>\n<li>在这次调用结束之后，runtime.gopanic 会从 runtime._defer 结构体中取出程序计数器 pc 和栈指针 sp 并调用 runtime.recovery 函数进行恢复程序；</li>\n<li>runtime.recovery 会根据传入的 pc 和 sp 跳转回 runtime.deferproc；</li>\n<li>编译器自动生成的代码会发现 runtime.deferproc 的返回值不为 0，这时会跳回 runtime.deferreturn 并恢复到正常的执行流程；</li>\n</ol>\n</li>\n<li>如果没有遇到 runtime.gorecover 就会依次遍历所有的 runtime._defer，并在最后调用 runtime.fatalpanic 中止程序、打印 panic 的参数并返回错误码 2；</li>\n</ol>\n<h4 id=\"make-new\">make new<a href=\"post/GO基础#make-new\"></a></h4><ol>\n<li>make :初始化chan map slice 内置数据结构 </li>\n<li>new: 根据传入类型，分配指定一片空间，并返回内存空间的指针</li>\n</ol>\n<h4 id=\"slice\">slice<a href=\"post/GO基础#slice\"></a></h4><p>nil 和空切片都可以直接append，但是json之后一个是nil，一个是[] </p>\n","prev":{"title":"Redis","slug":"Redis"},"next":{"title":"Go GC","slug":"Go-GC"},"link":"https://vale-sail.github.io/post/GO基础/"}