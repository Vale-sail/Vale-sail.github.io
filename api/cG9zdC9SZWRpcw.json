{"title":"Redis","date":"2021-12-01T09:07:00.000Z","author":"Vale Sail","slug":"Redis","tags":["redis"],"categories":["学习笔记"],"updated":"2021-12-01T09:35:22.564Z","content":"<h4 id=\"Redis-有哪些数据结构？\">Redis 有哪些数据结构？<a href=\"post/Redis#Redis-有哪些数据结构？\"></a></h4><ol>\n<li>字符串 String (SDS 动态字符串,二进制安全)</li>\n<li>字典 Hash (压缩列表表 or 散列表+链表(Murmurhash12,解决冲突，渐进式扩容))</li>\n<li>列表 List (先进先出) （压缩列表【64 512】 or 双写循环链表）</li>\n<li>集合 Set (元素唯一) （数组 512证书 散列表）</li>\n<li>有序集合 SortedSet (top N) （压缩列表 64 128）（基于跳表实现）</li>\n<li>Geo 地址位置计算</li>\n<li>不常用的 HyperLogLog Pub/Sub RedisSearch Redis-ML</li>\n</ol>\n<h4 id=\"并发锁\">并发锁<a href=\"post/Redis#并发锁\"></a></h4><ol>\n<li>两条命令setNx + expire</li>\n<li>一条命令 set 特殊参数</li>\n</ol>\n<h4 id=\"key查找\">key查找<a href=\"post/Redis#key查找\"></a></h4><ol>\n<li>keys 但是由于redis 单进程特性，会阻塞其他命令，生产环境禁止使用</li>\n<li>scan 返回重复值</li>\n</ol>\n<h4 id=\"消息队列\">消息队列<a href=\"post/Redis#消息队列\"></a></h4><ol>\n<li>list rpush lpop(不阻塞) blpop(阻塞)</li>\n<li>pub/sub 消费者下线 生产者消息丢失</li>\n<li>beanstalkd 优先队列，延迟队列，超时重发</li>\n<li>kafka 顺序性，append高性能</li>\n<li>sortedset 延迟队列</li>\n</ol>\n<h4 id=\"key过期\">key过期<a href=\"post/Redis#key过期\"></a></h4><ol>\n<li>惰性删除(访问删除)</li>\n<li>定时删除(每次选择一部分删除部分)</li>\n</ol>\n<h5 id=\"key触发时机\">key触发时机<a href=\"post/Redis#key触发时机\"></a></h5><p>内存使用到达maxmemory 配置</p>\n<h5 id=\"key过期策略\">key过期策略<a href=\"post/Redis#key过期策略\"></a></h5><h6 id=\"所有key\">所有key<a href=\"post/Redis#所有key\"></a></h6><ol>\n<li>LRU <blockquote>\n<p>allkeys-lru 当内存不足时,所有key 按照最近最少使用清理</p>\n</blockquote>\n</li>\n<li>random<blockquote>\n<p>allkeys-random 当内存不足时,所有key 随机删除</p>\n</blockquote>\n</li>\n</ol>\n<h6 id=\"拥有ttl的key\">拥有ttl的key<a href=\"post/Redis#拥有ttl的key\"></a></h6><ol>\n<li>LRU<blockquote>\n<p>volatile-lru: 当内存不足时，所有设置了ttl的按照最近最少使用策略移除</p>\n</blockquote>\n</li>\n<li>random<blockquote>\n<p>volatile-random: 当内存不足时，所有设置了ttl的随机移除</p>\n</blockquote>\n</li>\n<li>ttl<blockquote>\n<p>volatile-ttl 当内存不足时,按照过期时间进行移除</p>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"拒绝写入\">拒绝写入<a href=\"post/Redis#拒绝写入\"></a></h5><p>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧</p>\n<h3 id=\"同步\">同步<a href=\"post/Redis#同步\"></a></h3><p>bgsave 全量持久化 redis 通过创建子进程来进行 bgsave 操作，cow 指的是 copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来 aof 增量持久化<br>配置刷新时间</p>\n<h3 id=\"业务使用的奇技淫巧\">业务使用的奇技淫巧<a href=\"post/Redis#业务使用的奇技淫巧\"></a></h3><ol>\n<li>分散过期时间，以免大量key同时过期导致redis卡顿.</li>\n<li>pipeline 使用pipeline 合并多条指令，这样就多条指令只有一次网络交互 </li>\n<li>一致性hash 减少机器增删 缓存的miss率 缓存的命中率监控 </li>\n</ol>\n<h3 id=\"Redis-的同步机制了解么？\">Redis 的同步机制了解么？<a href=\"post/Redis#Redis-的同步机制了解么？\"></a></h3><p>Redis 可以使用主从同步，从从同步。第一次同步时，主节点做一次 bgsave，并同时将后续修改操作记录到内存 buffer，待完成后将 rdb 文件全量同步到复制节点，复制节点接受完成后将 rdb<br>镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p>\n<h4 id=\"Redis-Sentinal\">Redis Sentinal<a href=\"post/Redis#Redis-Sentinal\"></a></h4><ol>\n<li>使用流言协议（gossip protocols)来接收关于主服务器是否下线的信息</li>\n<li>使用投票协议（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器。</li>\n</ol>\n<p>Sentinel主要负责三个方面的任务：</p>\n<ol>\n<li>监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li>\n<li>提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>\n<li><p>自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</p>\n</li>\n<li><p>主观下线</p>\n<blockquote>\n<p>Sentinal单个节点对于master做出下线判断</p>\n</blockquote>\n</li>\n<li>客观下线<blockquote>\n<p>多个Sentinal节点对于master做出下线判断</p>\n</blockquote>\n</li>\n</ol>\n<div class=\"article-img\"><p><img src=\"/images/image-redis-s.png\" alt=\"upload successful\" data-zoomable></p></div>\n<p>上图是一主一从节点，加上两个部署了sentinel的集群，sentinel集群之间会互相通信，沟通交流redis节点的状态，做出相应的判断并进行处理，这里的主观下线状态和客观下线状态是比较重要的状态，它们决定了是否进行故障转移<br>可以 通过订阅指定的频道信息，当服务器出现故障得时候通知管理员<br>客户端可以将 Sentinel 看作是一个只提供了订阅功能的 Redis 服务器，你不可以使用 PUBLISH 命令向这个服务器发送信息，但你可以用 SUBSCRIBE 命令或者 PSUBSCRIBE 命令， 通过订阅给定的频道来获取相应的事件提醒。 一个频道能够接收和这个频道的名字相同的事件。 比如说， 名为 +sdown 的频道就可以接收所有实例进入主观下线（SDOWN）状态的事件。</p>\n<h3 id=\"集群的原理是什么？\">集群的原理是什么？<a href=\"post/Redis#集群的原理是什么？\"></a></h3><ol>\n<li>Redis Sentinal 着眼于高可用，在 master 宕机时会自动将 slave 提升为 master，继续提供服务。 </li>\n<li>Redis Cluster 着眼于扩展性，在单个 redis 内存不足时，使用 Cluster进行分片存储。最多支持2^14-1个分片<br>16383个节点，节点间心跳通信需要消耗2K的流量。</li>\n</ol>\n","next":{"title":"GO基础","slug":"GO基础"},"link":"https://vale-sail.github.io/post/Redis/"}