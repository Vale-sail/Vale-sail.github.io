{"title":"关键字","date":"2021-12-03T07:10:00.000Z","author":"Vale Sail","slug":"关键字","tags":["go"],"categories":["学习笔记"],"updated":"2021-12-03T07:11:16.127Z","content":"<h3 id=\"Context\">Context<a href=\"post/关键字#Context\"></a></h3><blockquote>\n<p>用于多个协程之间同步信号，数据 在 Goroutine 构成的树形结构中对信号进行同步以减少计算资源的浪费是context.Context的最大作用。Go 服务的每一个请求都是通过单独的 Goroutine 处理，HTTP/RPC 请求的处理器会启动新的 Goroutine 访问数据库和其他服务。我们可能会创建多个 Goroutine 来处理一次请求，而context.Context的作用是在不同 Goroutine 之间同步请求特定数据、取消信号以及处理请求的截止日期。</p>\n</blockquote>\n<h4 id=\"基础结构\">基础结构<a href=\"post/关键字#基础结构\"></a></h4><ol>\n<li>Deadline 截止时间 WithTimeout</li>\n<li>Done 返回一个 Channel，这个 Channel 会在当前工作完成或者上下文被取消后关闭，多次调用Done方法会返回同一个 Channel；</li>\n<li>Err 返回context结束的原因<ol>\n<li>如果context.Context被取消，会返回Canceled错误； WithCancel</li>\n<li>如果context.Context超时，会返回DeadlineExceeded错误； WithTimeout</li>\n</ol>\n</li>\n<li>Value 从context.Context中获取键对应的值，对于同一个上下文来说，多次调用Value并传入相同的Key会返回相同的结果，该方法可以用来传递请求特定的数据 WithValue</li>\n</ol>\n<h3 id=\"sync\">sync<a href=\"post/关键字#sync\"></a></h3><h4 id=\"sync-mutex\">sync.mutex<a href=\"post/关键字#sync-mutex\"></a></h4><ol>\n<li><p>数据结构</p>\n<ol>\n<li>state 标示当前状态 最低三位分别是，其他标示等待的数量<ol>\n<li>mutexLocked 锁定状态</li>\n<li>mutexWoken从正常模式被唤醒</li>\n<li>mutexStarving 进入饥饿模式</li>\n</ol>\n</li>\n<li>sema 信号量</li>\n</ol>\n</li>\n<li><p>运行模式</p>\n<ol>\n<li>正常模式: 锁按照队列的顺序获取锁</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>但是刚被唤起的协程和刚刚创建的协程发生竞争，导致队列中协程长时间无法获取的锁<br>正常模式等待锁定 会进入自旋，如果未取到锁，进入饥饿模式，设置(runtime_SemacquireMutex)等待被被唤醒</p>\n</blockquote>\n<pre><code>2. 饥饿模式: 如果协程超过1ms 没有获取到锁，转为饥饿模式。\n</code></pre><blockquote>\n<p>饥饿模式协程会直接把锁给到队列头部的协程，如果队列尾部的协程等待时长小于1ms，将转为正常模式。<br>饥饿模式下不会自旋<br>引入目的:保证锁的公平性，防止协程长时间获取不到锁</p>\n</blockquote>\n<ol start=\"3\">\n<li>lock 流程<ol>\n<li>如果lock为未锁定状态，设置为锁定返回</li>\n<li>处于锁定模式&amp;&amp;正常模式下，自旋</li>\n<li>如果没有获取锁 进入饥饿模式</li>\n<li>通过runtime_SemacquireMutex等待被唤醒</li>\n<li>根据等待时间和等待长度 确定是否退出饥饿模式</li>\n</ol>\n</li>\n<li>unlock流程<ol>\n<li>已经解锁抛异常</li>\n<li>如果没有等待者直接返回</li>\n<li>如果有等待者，设置state最右侧为0并标记唤醒，执行runtime_Semrelease 唤醒其他协程</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"sync-RWMutex\">sync.RWMutex<a href=\"post/关键字#sync-RWMutex\"></a></h4><p>粒度更加写的锁，基于sync.mutex实现</p>\n<ol>\n<li>调用 sync.RWMutex.Lock 尝试获取写锁时； 每次 sync.RWMutex.RUnlock 都会将 readerCount 其减一，当它归零时该 Goroutine 会获得写锁； 将readerCount 减少<br>rwmutexMaxReaders 个数以阻塞后续的读操作；</li>\n<li>调用 sync.RWMutex.Unlock 释放写锁时，会先通知所有的读操作，然后才会释放持有的互斥锁；</li>\n</ol>\n<h4 id=\"sync-WaitGroup\">sync.WaitGroup<a href=\"post/关键字#sync-WaitGroup\"></a></h4><ol>\n<li>sync.WaitGroup 必须在 sync.WaitGroup.Wait 方法返回之后才能被重新使用；</li>\n<li>sync.WaitGroup.Done 只是对 sync.WaitGroup.Add 方法的简单封装，我们可以向 sync.WaitGroup.Add 方法传入任意负数（需要保证计数器非负）快速将计数器归零以唤醒等待的<br>Goroutine；</li>\n</ol>\n<blockquote>\n<p>add 可以传入负数，如果最终计数器为0，wait返回，如果计数器为-1 将会panic</p>\n</blockquote>\n<ol start=\"3\">\n<li>可以同时有多个 Goroutine 等待当前 sync.WaitGroup 计数器的归零，这些 Goroutine 会被同时唤醒；</li>\n</ol>\n<h4 id=\"sync-Once\">sync.Once<a href=\"post/关键字#sync-Once\"></a></h4><p>保证 Do的方法只执行一次，如果Do被多次调用，传入多个函数。但是仍然只会执行一次</p>\n<h4 id=\"sync-Cond\">sync.Cond<a href=\"post/关键字#sync-Cond\"></a></h4><ol>\n<li>sync.Cond.Wait 在调用之前一定要使用获取互斥锁，否则会触发程序崩溃；</li>\n<li>sync.Cond.Signal 唤醒的 Goroutine 都是队列最前面、等待最久的 Goroutine；</li>\n<li>sync.Cond.Broadcast 会按照一定顺序广播通知等待的全部 Goroutine；</li>\n</ol>\n<h4 id=\"sync-ErrGroup\">sync.ErrGroup<a href=\"post/关键字#sync-ErrGroup\"></a></h4><p>为一组 Goroutine 中提供了同步、错误传播以及上下文取消的功能</p>\n<h4 id=\"sync-map\">sync.map<a href=\"post/关键字#sync-map\"></a></h4><p>提供线程安全的map读写</p>\n<h4 id=\"sync-SingleFlight\">sync.SingleFlight<a href=\"post/关键字#sync-SingleFlight\"></a></h4><p>可以用于redis 缓存击穿请求加载数据</p>\n","prev":{"title":"SMTP邮件发送文件名乱码问题","slug":"SMTP邮件发送"},"next":{"title":"Redis","slug":"Redis"},"link":"https://vale-sail.github.io/post/关键字/"}