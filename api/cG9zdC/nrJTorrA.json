{"title":"笔记","date":"2021-04-19T03:20:08.000Z","slug":"笔记","updated":"2021-04-19T07:43:29.670Z","content":"<h3 id=\"Golang\">Golang<a href=\"post/笔记#Golang\"></a></h3><h4 id=\"Slice\">Slice<a href=\"post/笔记#Slice\"></a></h4><h5 id=\"空slice和0容量的slice的区别\">空slice和0容量的slice的区别<a href=\"post/笔记#空slice和0容量的slice的区别\"></a></h5><ol>\n<li>空slice和0容量slice 都可以正常的操作，操作表现一致</li>\n<li><p>0容量的slice !=nil json之后是 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 空slice ==nil json之后是 ```null</span><br></pre></td></tr></table></figure></p>\n</li>\n<li><p>底层实现空slice的数据指针是nil，slice指针指向zeroBase</p>\n<h4 id=\"net-http\"><a href=\"#net-http\" class=\"headerlink\" title=\"net/http\"></a>net/http</h4><h5 id=\"超时\"><a href=\"#超时\" class=\"headerlink\" title=\"超时\"></a>超时</h5></li>\n<li>在http.Transport设置超时，是连接创建时对于该域名的超时时间<br>由于golang使用http会维护自己的一个连接池，一个连接会被重复使用但是超时时间不会被重置，所以会在使用多次之后触发超时</li>\n<li>解决方式: 不在http.Transport设置读写超时，在创建http.client时设置时间<h3 id=\"PHP\"><a href=\"#PHP\" class=\"headerlink\" title=\"PHP\"></a>PHP</h3><h4 id=\"慢查询\"><a href=\"#慢查询\" class=\"headerlink\" title=\"慢查询\"></a>慢查询</h4></li>\n<li>慢日志</li>\n<li>xhprof</li>\n</ol>\n<h3 id=\"微服务\">微服务<a href=\"post/笔记#微服务\"></a></h3><h4 id=\"拆分\">拆分<a href=\"post/笔记#拆分\"></a></h4><ol>\n<li>领域拆分<h4 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h4><h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5></li>\n<li>服务独立部署，易于扩展</li>\n<li>服务开发边界明显，开发效率高，易于代码维护，易于测试，耦合度底<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5></li>\n<li>服务调用链路复杂，问题排查困难</li>\n<li>需要有完善的配套: 服务注册与发现</li>\n</ol>\n<h3 id=\"MQ\">MQ<a href=\"post/笔记#MQ\"></a></h3><h4 id=\"优势\">优势<a href=\"post/笔记#优势\"></a></h4><ol>\n<li>削峰</li>\n<li>解耦</li>\n<li>异步</li>\n</ol>\n<h3 id=\"缓存\">缓存<a href=\"post/笔记#缓存\"></a></h3><ol>\n<li>多级缓存</li>\n</ol>\n<h3 id=\"Http1与Http2\">Http1与Http2<a href=\"post/笔记#Http1与Http2\"></a></h3><h3 id=\"网络硬件\">网络硬件<a href=\"post/笔记#网络硬件\"></a></h3><h4 id=\"集线器-物理层\">集线器 物理层<a href=\"post/笔记#集线器-物理层\"></a></h4><ol>\n<li>单纯的数据复制转发，不识别数据，广播<h4 id=\"交换机-数据链路层\"><a href=\"#交换机-数据链路层\" class=\"headerlink\" title=\"交换机 数据链路层\"></a>交换机 数据链路层</h4></li>\n<li>自己不具有mac地址，但是维护一个mac地址表，转发到指定的mac地址</li>\n<li>如果源mac和目标mac一致，直接丢弃不转发</li>\n<li>如果目标mac找不到，广播到非源mac地址的所有</li>\n<li>由于交换机在数据链路层，会对数据进行FCS校验<h4 id=\"路由器-网络层\"><a href=\"#路由器-网络层\" class=\"headerlink\" title=\"路由器 网络层\"></a>路由器 网络层</h4></li>\n<li>自己具有mac地址，收到数据校验是否是自己的mac地址</li>\n<li>维护一个ip的路由表，改写源mac地址并转发到指定的ip</li>\n<li>路由表中找不到指定地址，直接丢弃数据包，并且通过ICMP回复发送方<h4 id=\"为什么要三次握手\"><a href=\"#为什么要三次握手\" class=\"headerlink\" title=\"为什么要三次握手\"></a>为什么要三次握手</h4><blockquote>\n<p>为了阻止历史的重复连接初始化造成的混乱问题，防止使用 TCP 协议通信的双方建立了错误的连接。</p>\n</blockquote>\n</li>\n<li>由于网络是不稳定的，数据传输可能发送丢失，延迟，重发。<br>如果采用两次握手，客户端发出请求就建立连接，可能服务端无法收到请求，只是客户端建立错误的连接，导致资源的浪费<br>如果采用两次握手，服务端收到超时的请求，建立错误的连接，导致资源浪费</li>\n</ol>\n","prev":{"title":"MQTT笔记","slug":"mqtt"},"next":{"title":"字节面试","slug":"字节面试—MySQL"},"link":"https://vale-sail.github.io/post/笔记/"}