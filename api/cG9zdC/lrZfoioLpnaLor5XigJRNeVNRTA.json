{"title":"字节面试","date":"2021-03-04T13:47:00.000Z","author":"Vale Sail","slug":"字节面试—MySQL","tags":["go"],"updated":"2021-11-29T07:56:10.127Z","content":"<h3 id=\"Golang\">Golang<a href=\"post/字节面试—MySQL#Golang\"></a></h3><h5 id=\"协程\">协程<a href=\"post/字节面试—MySQL#协程\"></a></h5><h5 id=\"协程的优势\">协程的优势<a href=\"post/字节面试—MySQL#协程的优势\"></a></h5><ol>\n<li>内存占用少(4K)</li>\n<li>协程由golang的runtime进行调度，在用户态完成，不需要涉及内核态和用户态的切换</li>\n</ol>\n<h5 id=\"协程的调度原理-GPM\">协程的调度原理 GPM<a href=\"post/字节面试—MySQL#协程的调度原理-GPM\"></a></h5><ol>\n<li>G:协程;P:处理器负责调度G;M:工作线程;每个P获取空闲的M进行绑定，P从自己的队列中获取需要执行的G，如果没有就从全局的队列中偷取一半的G，保存到自己的队列中，并且运行。如果</li>\n</ol>\n<h6 id=\"为什么一定需要P\">为什么一定需要P<a href=\"post/字节面试—MySQL#为什么一定需要P\"></a></h6><p>uWk9pzdREk.png!large.png<br><img src=\"/images/image.png\" alt=\"overwrote existing file\"></p>\n<ol>\n<li>如果没有P,G和M绑定;每次创建运行销毁G都需要M获取锁，这样就会资源竞争</li>\n<li>如果G在M上运行创建了新的G，则新的G不一定会在M上运行，这样局部性不好</li>\n<li>系统调用 (CPU 在 M 之间的切换) 导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li>\n</ol>\n<h4 id=\"MYSQL\">MYSQL<a href=\"post/字节面试—MySQL#MYSQL\"></a></h4><h5 id=\"B-树\">B+树<a href=\"post/字节面试—MySQL#B-树\"></a></h5><h5 id=\"脏读和幻读\">脏读和幻读<a href=\"post/字节面试—MySQL#脏读和幻读\"></a></h5><h5 id=\"GAP锁\">GAP锁<a href=\"post/字节面试—MySQL#GAP锁\"></a></h5>","prev":{"title":"笔记","slug":"笔记"},"next":{"title":"字节面试-PHP","slug":"字节面试"},"link":"https://vale-sail.github.io/post/字节面试—MySQL/"}